library(tidyverse)
library(shiny)
library(shinythemes)
library(DT)
library(eeptools)
library(jsonlite)
library(plotly)
library(glue)
library(dotenv)
library(shinycssloaders)

source("load_data.R")
# source("load_data_devel.R")
source("dropdownbutton.R")

addResourcePath(prefix = "img", directoryPath = "images")

bgCols <- c(population_intervention = "#0be60b", population = "#ff3333", none = "#e1e1e1")

ui <- fluidPage(
  theme = shinytheme("cerulean"),
  tags$style(
    type = "text/css",
    '
    h1 { margin-top:0;}
    .modal-lg { min-width: 1200px; }
    .comment-available { width:20px; height:20px; position:absolute; bottom:0; right: 0;}
    .dataTable td { position:relative; }
    .legend-icon { display:inline-block; width:20px; height:10px; }
    '
  ),
  tags$script(src = "batterybar.js"),
  #*************************************************************************
  fluidRow(
    column(
      2,
      img(src = "img/celida-logo-white.png", height = 100),
    ),
    column(2, img(src = "img/logo_num.jpg", height = 100)),
    column(5,
      h2("Guideline Recommendation"),
      dropdownButton(
        label = "Guideline Recommendation",
        status = "default",
        width = "100%",
        tags$div(
          class = "container",
          checkboxGroupInput(
            inputId = "recommendation_url",
            label = "Guideline Recommendation",
            width = "100%",
            choiceNames = lapply(recommendations %>% str_glue_data("<b>[{short}]</b> {recommendation_title}"), HTML),
            choiceValues = recommendations$recommendation_url,
            selected = recommendations$recommendation_url
          )
        )
      ),
      align = "center"
    ),
    column(3,
      dateRangeInput(
        inputId = "observation_window",
        label = h2("Date range"),
        start = Sys.Date() - 65,
        end = Sys.Date(),
        min = "2021-01-01",
        max = Sys.Date(),
        width = "100%",
      ),
      align = "center",
    )
  ),

  #*************************************************************************
  # Content Row

  fluidRow(

    # Patient Table Column
    column(
      12,
      wellPanel(
        DT::dataTableOutput("patienttable") %>% shinycssloaders::withSpinner(type = 6),
        h3("Legend"),
        div(class="legend-icon", style = paste0("background-color:", bgCols["population_intervention"], ";")),
        "Patient is treated according to the recommendation",
        br(),
        div(class="legend-icon", style = paste0("background-color:", bgCols["population"], ";")),
        "Patient is not treated according to the recommendation",
        br(),
        div(class="legend-icon", style = paste0("background-color:", bgCols["none"], ";")),
        "Recommendation not applicable to the patient",
        br(),
        div(class="legend-icon", HTML("&#x1F4AC")),
        "Comment available",
        br(),
        align = "left"
      )
    )
  )
)


getPlotUIs <- function(vars, type) {
  #' @title getPlotUIs
  #'
  #' @description
  #' Render a list of tabPanels with plotly outputs for the given variables
  #' This function is used to populate the different tabs for population
  #' and intervention variables each time a new guideline recommendation is
  #' selected. See setPlotUIOutputs() for how the tabs are filled with plots.
  #'
  #' @param vars a vector of variables to display as separate tabs in the tabsetPanel
  #' @param type a string indicating whether this is a population or an intervention plot
  #'
  #' @return A Shiny UI component containing a list of tabPanels, each displaying a plotly plot for one of the given variables
  #'
  #' @examples
  #' getPlotUIs(vars = c("variable1", "variable2"), type = "intervention")
  #'
  return(renderUI({
    myTabs <- map(vars, ~ tabPanel(
      title = as.character(.x), # variable title
      wellPanel(
        plotlyOutput(paste("plot", type, .x, sep = "_"), height = 350),
        style = "padding:0;margin-bottom:0;"
      )
    ))

    do.call(tabsetPanel, c(myTabs, list(id = glue("{type}Panel"))))
  }))
}


setPlotUIOutputs <- function(output, person_id, run_id, vars, type, min_dt, max_dt) {
  #' @title setPlotUIOutputs
  #'
  #' @description
  #' Set plot outputs for the given variables in the Shiny output object.
  #' This function creates plotly output elements for each tab generated by
  #' getPlotUIs().
  #'
  #' @param output a Shiny output object where the plot outputs will be stored
  #' @param person_id an ID for the person whose data will be displayed
  #' @param run_id an ID for the run from which the data will be displayed
  #' @param vars a vector of variables to be displayed as separate plots
  #' @param type a string indicating the type of plots to be displayed
  #' @param min_dt minimal datetime displayed in the plot
  #' @param max_dt maximal datetime displayed in the plot
  #'
  #' @return A Shiny output object with plot outputs for the given variables stored in it
  #'
  #' @examples
  #' setPlotUIOutputs(output, person_id = 123, run_id = 456, vars = c("variable1", "variable2"), type = "intervention")
  #'
  vars <- vars %>%
    filter(type == !!type) %>%
    # TODO: The next line drops unique criterion_name if there are more than 1
    # per variable_name. This is intended at this point in order to show each
    # variable just once, but may not be correct behaviour in general.
    distinct(variable_name, .keep_all = TRUE)

  for (i in seq_len(nrow(vars))) {
    var <- vars$variable_name[i]
    criterion_name <- vars$criterion_name[i]


    local({
      plotname <- paste("plot", type, var, sep = "_")
      localvar <- var

      data <- load_data(person_id = person_id, run_id = run_id, criterion_name = criterion_name)

      output[[plotname]] <- renderPlotly({
        if (is.null(data) || nrow(data) == 0) {
          # no data
          # browser()
          ggp <- ggplot() +
            geom_blank() +
            expand_limits(x = c(min_dt, max_dt), y = c(0, 1))
        } else if (class(data$value) == "factor") {
          # categorical variables
          ggp <- ggplot(data, aes(x = datetime, y = value, group = value)) +
            geom_step(aes(group = 1)) +
            geom_point()
        } else if (any(data$datetime != data$end_datetime)) {
          # time periods
          ggp <- ggplot(data, aes(y = value, yend = value, x = datetime, xend = end_datetime)) +
            geom_segment(linewidth = 1) +
            geom_point()
        } else if (class(data$value) == "logical") {
          # boolean variables
          ggp <- ggplot(data, aes(x = datetime, ymin = 0, y = value, ymax = value)) +
            geom_linerange() +
            geom_point()
        } else {
          # continuous data
          ggp <- ggplot(data, aes(datetime, value)) +
            geom_line() +
            geom_point()
        }

        ggplotly(ggp +
          xlab("Date") +
          ylab(localvar) +
          coord_cartesian(xlim = c(min_dt, max_dt)))
      })
    })
  }
}
##############################################################################

############# Server ############
server <- function(input, output, session) {
  n_fixed_columns <- 3 # number of fixed columns before the recommendation columns (3: Name, Ward, Comment)

  # REACTIVE VALUES

  # Overview of patients and the P/I state (for left side)
  # This tibble contains one patient per row, "name" and "ward" as columns and
  # for each selected guideline recommendations a column with one of "PI", "P",
  # "I" or "o", indicating whether the patient belongs to (P)opulation,
  # (I)ntervention, Population & Intervention (PI) or none (o).
  patient_overview <- reactive({
    load_patient_list(isolate(input$recommendation_url), start_datetime = format(input$observation_window[1]), end_datetime = format(input$observation_window[2]))
  })

  # Patient overview filtered by ward
  # Second reactive variable that just filters the patient_overview by the ward
  # This is used to not having to update the patient_overview() each time a
  # filter on ward is selected
  patient_data <- reactive({
    patient_overview()$patients
  })
  
  # Comment available indicator
  patient_comments <- reactive({
    patient_overview()$comments
  })

  # Observe cell clicks and set person_id and recommendation_url accordingly
  rv <- reactiveValues()

  rv$table_initialized <- FALSE

  rv$selected_person_id <- reactive({
    patient_data()[input$patienttable_cells_selected[1], ]$person_id
  })

  rv$selected_recommendation_url <- reactive({
    if ((length(input$patienttable_cells_selected) > 0) && (input$patienttable_cells_selected[2] > n_fixed_columns - 1)) {
      input$recommendation_url[input$patienttable_cells_selected[2] - n_fixed_columns + 1]
    }
  })

  # used to observe if either person_id or recommendation_url has changed
  rv$selection_changed <- reactive({
    list(rv$selected_person_id(), rv$selected_recommendation_url())
  })

  # observer to show modal dialog (with population/intervention data)
  # does fire every time a cell is clicked, because rv$selected_recommendation_url
  # is set every time (it does not check whether a different cell/recommendation)
  # has been selected compared to the previous selection
  # rv$selection_changed shouldn't be used here because event is fired when
  # the data table is initalized --> would display the modal dialog before clicking
  observeEvent(rv$selected_recommendation_url(), {
    showModal(dataModal())
  })


  ##############################################################################
  # Footer (code to display summary statistics)
  ##############################################################################

  footerJS <- paste0("
  function(row, data, start, end, display) {
    var api = this.api(), data;
    var intVal = function (i, match) {
        return typeof i === 'string' ?  (i ===  match ? 1 : 0) : typeof i === 'number' ? i : 0;
    };
    for(i=", n_fixed_columns, "; i<api.columns().nodes().length;i++) {
      var p = api.column(i, { search: 'applied' }).data().reduce(function(a, b) {return intVal(a) + intVal(b) });
      p /= api.column(i, { search: 'applied' }).data().length;
      $( api.column(i).footer() ).html(p.toFixed(0) + '%');
    }
  }")

  ##############################################################################

  shinyInput <- function(FUN, len, id, ...) {
    inputs <- character(len)
    for (i in seq_len(len)) {
      inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
    }
    inputs
  }


  # Patient data table
  options(DT.options = list(pageLength = 20))
  observeEvent(input$recommendation_url, {
    recommendation_names_short <- (recommendations %>% filter(recommendation_url %in% input$recommendation_url))$short

    colnames <- c("Patient", "Ward", recommendation_names_short)
    colnames_comment <- c("Patient", "Ward", "Comment", recommendation_names_short)

    output$patienttable <- DT::renderDataTable(
      server = FALSE,
      DT::datatable(
        patient_data() %>%
          select(all_of(colnames)) %>%
          add_column(shinyInput(textAreaInput, nrow(patient_data()), "cbox_"), .after = "Ward"),
        container = htmltools::withTags(table(tableHeader(c(colnames_comment)), tableFooter(rep_along(colnames_comment, "")))),
        rownames = FALSE,
        filter = list(
          position = "top",
          pageLength = 5,
          autoWidth = TRUE,
          clear = TRUE
        ),
        selection = list(
          mode = "single",
          target = "cell",
          selectable = as.matrix(expand.grid(seq_len(nrow(patient_data())), seq(n_fixed_columns, length(colnames))))
        ),
        colnames = colnames,
        extensions = c("FixedHeader", "Responsive"),
        escape = FALSE,
        options = list(
          autoWidth = FALSE,
          bAutoWidth = FALSE,
          fixedHeader = TRUE,
          footerCallback = JS(footerJS),
          columnDefs = list(
            list(
              className = "dt-center", targets = seq(0, length(colnames_comment) - 1)
            )
          ),
          rowCallback = JS(
            paste0("
            function(row, data) {
              let colormap = {
                 '1': '", bgCols["population_intervention"], "',
                 '0': '", bgCols["population"], "',
                '-1': '", bgCols["none"], "'
              };
              for (i = ", n_fixed_columns, "; i < ", length(colnames_comment), "; i++) {
                $('td', row).eq(i).css('border', 'solid black 1px');
                $('td', row).eq(i).css('background', styleBatteryBar(sampleWithReplacement([-1,0,1], 10), colormap));
                $('td', row).eq(i).css('background-repeat','no-repeat');
                $('td', row).eq(i).css('background-position','center');
                $('td', row).eq(i).css('background-size','98% 88%')
                if(Math.random() > 0.5) {
                  var div = $('<div>').html('&#x1F4AC;').addClass('comment-available');
                  $('td', row).eq(i).append(div);
                }
                
              }
            }")
          ),
          reDrawCallback = JS("function() { Shiny.unbindAll(this.api().table().node()); }"),
          drawCallback = JS("function() { Shiny.bindAll(this.api().table().node()); } ")
        )
      ) %>%
        formatCurrency(columns = recommendation_names_short, currency = "%", before = FALSE, digits = 0)
    )
  })


  ##### Functions for popup window #####

  output$recommendation_text <- renderUI({
    if (!is.null(rv$selected_recommendation_url())) {
      HTML(recommendations %>% filter(recommendation_url == rv$selected_recommendation_url()) %>% pull(recommendation_description))
    }
  })

  observeEvent(rv$selected_recommendation_url(),
    {
      rv$recommendation_criteria <- load_recommendation_variables(rv$selected_recommendation_url())
      rv$vars_population <- rv$recommendation_criteria %>%
        filter(type == "population") %>%
        pull(variable_name) %>%
        unique() %>%
        as.list()

      rv$vars_intervention <- rv$recommendation_criteria %>%
        filter(type == "intervention") %>%
        pull(variable_name) %>%
        unique() %>%
        as.list()

      #### Create divs######
      output$population_main <- getPlotUIs(rv$vars_population, "population")
      output$intervention_main <- getPlotUIs(rv$vars_intervention, "intervention")
    },
    priority = 1 # make sure this is run before observeEvent(rv$selection_changed())
  )

  observeEvent(rv$selection_changed(),
    {
      if (is.null(rv$selected_recommendation_url())) {
        return()
      }

      run_id <- patient_overview()$run_id %>%
        filter(url == rv$selected_recommendation_url()) %>%
        pull(run_id)

      min_dt <- as.POSIXct(format(input$observation_window[1]))
      max_dt <- as.POSIXct(format(input$observation_window[2]))

      setPlotUIOutputs(output, person_id = rv$selected_person_id(), run_id = run_id, vars = rv$recommendation_criteria, type = "population", min_dt = min_dt, max_dt = max_dt)
      setPlotUIOutputs(output, person_id = rv$selected_person_id(), run_id = run_id, vars = rv$recommendation_criteria, type = "intervention", min_dt = min_dt, max_dt = max_dt)
    },
    priority = 0 # make sure this is run after observeEvent(rv$selected_recommendation_url(), ...)
  )

  # Return the UI for a modal dialog with data selection input. If 'failed' is
  # TRUE, then display a message that the previous value was invalid.
  dataModal <- function(failed = FALSE) {
    modalDialog(
      wellPanel(
        h1("Guideline Recommendation"),
        htmlOutput("recommendation_text"),
        tags$head(tags$style("#recommendation_text { font-size:18px; max-height: 20%; }")),
      ),
      # recommendation-Population Row
      wellPanel(
        h1("Population"),
        uiOutput("population_main", height = "500px") %>% shinycssloaders::withSpinner(type = 6, proxy.height = "300px", hide.ui = FALSE)
      ),

      # recommendation-Intervention Row
      wellPanel(
        h1("Intervention"),
        uiOutput("intervention_main") %>% shinycssloaders::withSpinner(type = 6, proxy.height = "300px", hide.ui = FALSE)
      ),

      # Comment
      wellPanel(
        h1("Comments"),
        textAreaInput(
          inputId = "comment",
          label = "",
          placeholder = "Make comments on patient's treatment",
          width = "100%",
          height = "96px",
        ),
        verbatimTextOutput("comment"),
        align = "left"
      ),
      footer = tagList(
        modalButton("Dismiss"),
      ),
      size = "l",
      easyClose = TRUE
    )
  }
}

shinyApp(ui = ui, server = server)
