library(tidyverse)
library(shiny)
library(shinythemes)
library(shinyWidgets)
library(DT)
library(eeptools)
library(jsonlite)
library(plotly)
library(glue)
library(dotenv)
library(shinycssloaders)

source("load_data.R")
# source("load_data_devel.R")
source("ui_utils.R")

addResourcePath(prefix = "img", directoryPath = "images")


ui <- fluidPage(
  theme = shinytheme("cerulean"),
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = paste0("celida.css?", generate_random_string()))
  ),
  tags$script(src = paste0("process-cell-data.js?", generate_random_string())),
  tags$script(src = paste0("batterybar.js?", generate_random_string())),
  #*************************************************************************
  fluidRow(
    column(
      2,
      img(src = "img/celida-logo-white.png", height = 100)
    ),
    column(2, img(src = "img/logo_num.jpg", height = 100)),
    column(5,
      h2("Guideline Recommendation"),
      dropdownButton(
        label = "Guideline Recommendation",
        #status = "default",
        status = "primary",
        
          checkboxGroupInput(
            inputId = "recommendation_url",
            label = "Guideline Recommendation",
            width = "100%",
            choiceNames = lapply(recommendations %>% str_glue_data("<b>[{short}]</b> {recommendation_title}"), HTML),
            choiceValues = recommendations$recommendation_url,
            selected = recommendations$recommendation_url
          )
        
      ),
      align = "center"
    ),
    column(3,
      dateRangeInput(
        inputId = "observation_window",
        label = h2("Date range"),
        start = Sys.Date() - 65,
        end = Sys.Date(),
        min = "2021-01-01",
        max = Sys.Date(),
        width = "100%",
      ),
      align = "center",
    )
  ),

  #*************************************************************************
  # Content Row

  fluidRow(

    # Patient Table Column
    column(
      12,
      wellPanel(
        DT::dataTableOutput("patienttable") %>% shinycssloaders::withSpinner(type = 6),
        h3("Legend"),
        div(class="legend-icon", style = "background-color: var(--population-intervention-color);"),
        "Patient is treated according to the recommendation",
        br(),
        div(class="legend-icon", style = "background-color: var(--population-color);"),
        "Patient is not treated according to the recommendation",
        br(),
        div(class="legend-icon", style = "background-color: var(--none-color);"),
        "Recommendation not applicable to the patient",
        br(),
        div(class="legend-icon", HTML("&#x1F4AC")),
        "Comment available",
        br(),
        align = "left"
      )
    )
  )
)


getPlotUIs <- function(vars, type) {
  #' @title getPlotUIs
  #'
  #' @description
  #' Render a list of tabPanels with plotly outputs for the given variables
  #' This function is used to populate the different tabs for population
  #' and intervention variables each time a new guideline recommendation is
  #' selected. See setPlotUIOutputs() for how the tabs are filled with plots.
  #'
  #' @param vars a vector of variables to display as separate tabs in the tabsetPanel
  #' @param type a string indicating whether this is a population or an intervention plot
  #'
  #' @return A Shiny UI component containing a list of tabPanels, each displaying a plotly plot for one of the given variables
  #'
  #' @examples
  #' getPlotUIs(vars = c("variable1", "variable2"), type = "intervention")
  #'
  return(renderUI({
    myTabs <- map(vars, ~ tabPanel(
      title = as.character(.x), # variable title
      wellPanel(
        plotlyOutput(paste("plot", type, .x, sep = "_"), height = 350),
        style = "padding:0;margin-bottom:0;"
      )
    ))

    do.call(tabsetPanel, c(myTabs, list(id = glue("{type}Panel"))))
  }))
}


setPlotUIOutputs <- function(output, person_id, run_id, vars, type, min_dt, max_dt) {
  #' @title setPlotUIOutputs
  #'
  #' @description
  #' Set plot outputs for the given variables in the Shiny output object.
  #' This function creates plotly output elements for each tab generated by
  #' getPlotUIs().
  #'
  #' @param output a Shiny output object where the plot outputs will be stored
  #' @param person_id an ID for the person whose data will be displayed
  #' @param run_id an ID for the run from which the data will be displayed
  #' @param vars a vector of variables to be displayed as separate plots
  #' @param type a string indicating the type of plots to be displayed
  #' @param min_dt minimal datetime displayed in the plot
  #' @param max_dt maximal datetime displayed in the plot
  #'
  #' @return A Shiny output object with plot outputs for the given variables stored in it
  #'
  #' @examples
  #' setPlotUIOutputs(output, person_id = 123, run_id = 456, vars = c("variable1", "variable2"), type = "intervention")
  #'
  vars <- vars %>%
    filter(type == !!type) %>%
    # TODO: The next line drops unique criterion_name if there are more than 1
    # per variable_name. This is intended at this point in order to show each
    # variable just once, but may not be correct behaviour in general.
    distinct(variable_name, .keep_all = TRUE)

  for (i in seq_len(nrow(vars))) {
    var <- vars$variable_name[i]
    criterion_name <- vars$criterion_name[i]


    local({
      plotname <- paste("plot", type, var, sep = "_")
      localvar <- var

      data <- load_data(person_id = person_id, run_id = run_id, criterion_name = criterion_name)

      output[[plotname]] <- renderPlotly({
        if (is.null(data) || nrow(data) == 0) {
          # no data
          # browser()
          ggp <- ggplot() +
            geom_blank() +
            expand_limits(x = c(min_dt, max_dt), y = c(0, 1))
        } else if (class(data$value) == "factor") {
          # categorical variables
          ggp <- ggplot(data, aes(x = datetime, y = value, group = value)) +
            geom_step(aes(group = 1)) +
            geom_point()
        } else if (any(data$datetime != data$end_datetime)) {
          # time periods
          ggp <- ggplot(data, aes(y = value, yend = value, x = datetime, xend = end_datetime)) +
            geom_segment(linewidth = 1) +
            geom_point()
        } else if (class(data$value) == "logical") {
          # boolean variables
          ggp <- ggplot(data, aes(x = datetime, ymin = 0, y = value, ymax = value)) +
            geom_linerange() +
            geom_point()
        } else {
          # continuous data
          ggp <- ggplot(data, aes(datetime, value)) +
            geom_line() +
            geom_point()
        }

        ggplotly(ggp +
          xlab("Date") +
          ylab(localvar) +
          coord_cartesian(xlim = c(min_dt, max_dt)))
      })
    })
  }
}
##############################################################################

############# Server ############
server <- function(input, output, session) {
  # TODO: make dynamic
  n_fixed_columns <- 3 # number of fixed columns before the recommendation columns (3: Name, Ward, Comment)

  # REACTIVE VALUES

  # Overview of patients and the P/I state (for left side)
  # This tibble contains one patient per row, "name" and "ward" as columns and
  # for each selected guideline recommendations a column with one of "PI", "P",
  # "I" or "o", indicating whether the patient belongs to (P)opulation,
  # (I)ntervention, Population & Intervention (PI) or none (o).
  patient_overview <- reactive({
    load_patient_list(isolate(input$recommendation_url), start_datetime = format(input$observation_window[1]), end_datetime = format(input$observation_window[2]))
  })

  # Patient overview filtered by ward
  # Second reactive variable that just filters the patient_overview by the ward
  # This is used to not having to update the patient_overview() each time a
  # filter on ward is selected
  patient_data <- reactive({
    patient_overview()$patients
  })
  
  # Observe cell clicks and set person_id and recommendation_url accordingly
  rv <- reactiveValues()

  rv$table_initialized <- FALSE

  rv$selected_person_id <- reactive({
    patient_data()[input$patienttable_cells_selected[1], ]$person_id
  })
  

  rv$selected_recommendation_url <- reactive({
    if ((length(input$patienttable_cells_selected) > 0) && (input$patienttable_cells_selected[2] > n_fixed_columns - 1)) {
      print(input$patienttable_cells_selected)
      input$recommendation_url[input$patienttable_cells_selected[2] - n_fixed_columns + 1]
    }
  })

  # used to observe if either person_id or recommendation_url has changed
  rv$selection_changed <- reactive({
    list(rv$selected_person_id(), rv$selected_recommendation_url())
  })

  # observer to show modal dialog (with population/intervention data)
  # does fire every time a cell is clicked, because rv$selected_recommendation_url
  # is set every time (it does not check whether a different cell/recommendation)
  # has been selected compared to the previous selection
  # rv$selection_changed shouldn't be used here because event is fired when
  # the data table is initalized --> would display the modal dialog before clicking
  observeEvent(rv$selected_recommendation_url(), {
    showModal(dataModal())
  })


  ##############################################################################

  shinyInput <- function(FUN, len, id, ...) {
    inputs <- character(len)
    for (i in seq_len(len)) {
      inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
    }
    inputs
  }


  # Patient data table
  options(DT.options = list(pageLength = 20))
  
  rv$colnames_expanded <- reactive({
    recommendation_names_short <- (recommendations %>% filter(recommendation_url %in% input$recommendation_url))$short
    expand_colnames(recommendation_names_short)
  })
  
  rv$colnames_comment <- reactive({
    c("Patient", "Ward", "Comment", rv$colnames_expanded())
  })
  
  rv$columnDefs <- reactive({
    generate_columnDefs(rv$colnames_comment())
  })
  
  rv$data <- reactive({
    data <- patient_data() %>%
      select(all_of( c("Patient", "Ward", rv$colnames_expanded()))) %>%
      add_column(shinyInput(textAreaInput, nrow(patient_data()), "cbox_"), .after = "Ward")
  })
  
  output$patienttable <- DT::renderDataTable(
    DT::datatable(
      rv$data(),
      container = htmltools::withTags(table(tableHeader(c(rv$colnames_comment())), tableFooter(rep_along(rv$colnames_comment(), "")))),
      rownames = FALSE,
      filter = list(
        position = "top",
        pageLength = 5,
        autoWidth = TRUE,
        clear = TRUE
      ),
      selection = 'none',#list(
      #  mode = "single",
      #  target = "cell",
      #  selectable = as.matrix(expand.grid(seq_len(nrow(patient_data())), seq(n_fixed_columns, length(rv$colnames_comment()))))
      #),
      extensions = c("FixedHeader", "Responsive", "Select"),
      escape = FALSE,
      options = list(
        columnDefs = c(
          rv$columnDefs(),
          list(list(className = "dt-center", targets = seq(0, length(rv$colnames_comment()) - 1))) # center the contents of all cells
        ),
        dom = 'tipr',
        select = list(
          style="single", 
          items="cell",
          selector=".data-cell"
        ),
        autoWidth = FALSE,
        bAutoWidth = FALSE,
        fixedHeader = TRUE,
        footerCallback = JS("function(row, data, start, end, display) { footerSummary(this.api(), row, data, start, end, display); }"),
        rowCallback = JS("function(row, data, displayNum) { processCellData(this.api(), row, data, displayNum); }"),
        reDrawCallback = JS("function() { Shiny.unbindAll(this.api().table().node()); }"),
        drawCallback = JS("function() { Shiny.bindAll(this.api().table().node()); } "),
        initComplete = JS("function() { onInitComplete(this.api()); }")
      )
    ),
    
    # disable server-side processing of data table input (see https://rstudio.github.io/DT/server.html) 
    # - required because we are using tibbles with named lists as cell items which (as of 23-04-03) cannot
    #   be processed by the server (with an error like "DataTables warning: table id=DataTables_Table_0 - 
    #   Error in `[<-.data.frame`(`*tmp*`, , j, value = list(structure(list(A = c("A", : replacement element 1 is a matrix/data frame of 3 rows, need 2)"
    server = FALSE, 
  )

  



  ##### Functions for popup window #####

  output$recommendation_text <- renderUI({
    if (!is.null(rv$selected_recommendation_url())) {
      HTML(recommendations %>% filter(recommendation_url == rv$selected_recommendation_url()) %>% pull(recommendation_description))
    }
  })

  observeEvent(rv$selected_recommendation_url(),
    {
      rv$recommendation_criteria <- load_recommendation_variables(rv$selected_recommendation_url())
      rv$vars_population <- rv$recommendation_criteria %>%
        filter(type == "population") %>%
        pull(variable_name) %>%
        unique() %>%
        as.list()

      rv$vars_intervention <- rv$recommendation_criteria %>%
        filter(type == "intervention") %>%
        pull(variable_name) %>%
        unique() %>%
        as.list()

      #### Create divs ######
      output$population_main <- getPlotUIs(rv$vars_population, "population")
      output$intervention_main <- getPlotUIs(rv$vars_intervention, "intervention")
    },
    priority = 1 # make sure this is run before observeEvent(rv$selection_changed())
  )

  observeEvent(rv$selection_changed(),
    {
      if (is.null(rv$selected_recommendation_url())) {
        return()
      }

      run_id <- patient_overview()$run_id %>%
        filter(url == rv$selected_recommendation_url()) %>%
        pull(run_id)

      min_dt <- as.POSIXct(format(input$observation_window[1]))
      max_dt <- as.POSIXct(format(input$observation_window[2]))

      setPlotUIOutputs(output, person_id = rv$selected_person_id(), run_id = run_id, vars = rv$recommendation_criteria, type = "population", min_dt = min_dt, max_dt = max_dt)
      setPlotUIOutputs(output, person_id = rv$selected_person_id(), run_id = run_id, vars = rv$recommendation_criteria, type = "intervention", min_dt = min_dt, max_dt = max_dt)
    },
    priority = 0 # make sure this is run after observeEvent(rv$selected_recommendation_url(), ...)
  )

  # Return the UI for a modal dialog with data selection input. If 'failed' is
  # TRUE, then display a message that the previous value was invalid.
  dataModal <- function(failed = FALSE) {
    modalDialog(
      wellPanel(
        h1("Guideline Recommendation"),
        htmlOutput("recommendation_text"),
        tags$head(tags$style("#recommendation_text { font-size:18px; max-height: 20%; }")),
      ),
      # recommendation-Population Row
      wellPanel(
        h1("Population"),
        uiOutput("population_main", height = "500px") %>% shinycssloaders::withSpinner(type = 6, proxy.height = "300px", hide.ui = FALSE)
      ),

      # recommendation-Intervention Row
      wellPanel(
        h1("Intervention"),
        uiOutput("intervention_main") %>% shinycssloaders::withSpinner(type = 6, proxy.height = "300px", hide.ui = FALSE)
      ),

      # Comment
      wellPanel(
        h1("Comments"),
        textAreaInput(
          inputId = "comment",
          label = "",
          placeholder = "Make comments on patient's treatment",
          width = "100%",
          height = "96px",
        ),
        verbatimTextOutput("comment"),
        align = "left"
      ),
      footer = tagList(
        modalButton("Dismiss"),
      ),
      size = "l",
      easyClose = TRUE
    )
  }
}

shinyApp(ui = ui, server = server)
